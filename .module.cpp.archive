// Copyright (c) 2024 - The University of Texas at Austin
//  This work was produced under contract #2317831 to National Technology and
//  Engineering Solutions of Sandia, LLC which is under contract
//  No. DE-NA0003525 with the U.S. Department of Energy.
// module.cpp - Pybind module interface
// Performance simulation of neuromorphic architectures
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "module.hpp"

namespace py = pybind11;

sana_fe::sana_fe()
{
	init();
}
void sana_fe::init()
{
	arch = arch_init();
	network_init(&net);
	INFO("Initializing simulation.\n");
	sim = sim_init_sim();
}
int sana_fe::update_neuron(int group_id, int n_id, vector<string> kwargs,
	int count)
{
	for (string item: kwargs)
	{
		INFO("Kwarg: %s\n", item.c_str());
	}
	if (count < 1)
	{
		return -1;
	}
	if (group_id >= net.neuron_group_count)
	{
		return -1;
	}
	if (n_id >= net.groups[group_id].neuron_count)
	{
		return -1;
	}

	struct attributes attr[128];
	for (int i = 0; i < count; ++i)
	{
		string s = kwargs[i];
		strcpy(&attr->key[i], s.substr(0, s.find('=')).c_str());
		strcpy(&attr->value_str[i], s.substr(s.find('=')+1).c_str());
		INFO("neuron: %d.%d updated with key: %s and val: %s\n",
			group_id, n_id, &attr->key[i], &attr->value_str[i]);
	}
	net.groups[group_id].neurons[n_id].soma_class->parameters(attr, count);
	return 1;
}

void sana_fe::run_timesteps(int timesteps){
	store_data_init(&run_data, sim, timesteps);
	for (int i = 0; i < timesteps; ++i){
		++sim->ts.timestep;
		run(sim, &net, arch);
	}
	store_data(&run_data, sim);
}
void sana_fe::set_input(char *filename){
	input_fp = fopen(filename, "r");
	if (input_fp == NULL)
	{
		INFO("Error: Couldn't open inputs %s.\n", filename);
		clean_up(RET_FAIL);
	}
}
void sana_fe::set_perf_flag(bool flag){
	if (flag){
		sim->log_perf = 1;

		sim->perf_fp = fopen("perf.csv", "w");
		if (sim->perf_fp == NULL)
		{
			INFO("Error: Couldn't open perf file for writing.\n");
			clean_up(RET_FAIL);
		}
		sim_perf_write_header(sim->perf_fp);
	}
	else{
		sim->log_perf = 0;
		if (sim->perf_fp != NULL)
			fclose(sim->perf_fp);
	}
}
void sana_fe::open_spike_trace(void)
{
	sim->log_spikes = 1;

	sim->spike_trace_fp = fopen("spikes.trace", "w");
	if (sim->spike_trace_fp == NULL)
	{
		INFO("Error: Couldn't open trace file for writing.\n");
		clean_up(RET_FAIL);
	}
	sim_spike_trace_write_header(sim);
}
void sana_fe::open_potential_trace(void)
{
	if (flag){
		sim->log_potential = 1;

		sim->potential_trace_fp = fopen("potential.trace", "w");
		if (sim->potential_trace_fp == NULL)
		{
			INFO("Error: Couldn't open trace file for writing.\n");
			clean_up(RET_FAIL);
		}
		sim_potential_trace_write_header(sim, &net);
	}
	else{
		sim->log_potential = 0;
		if (sim->potential_trace_fp != NULL)
			fclose(sim->potential_trace_fp);
	}
}

void sana_fe::open_message_trace(void)
{
	sim->log_messages = 1;

	sim->message_trace_fp = fopen("messages.trace", "w");
	if (sim->message_trace_fp == NULL)
	{
		INFO("Error: Couldn't open trace file for writing.\n");
		clean_up(RET_FAIL);
	}
	sim_message_trace_write_header(sim);
}

void sana_fe::set_gui_flag(bool flag){
	sim->gui_on = 1;
	arch->spike_vector_on = 1;
}
void sana_fe::set_arch(char* filename)
{
	FILE* arch_fp = fopen(filename, "r");
	if (arch_fp == NULL)
	{
		INFO("Error: Architecture file %s failed to open.\n", filename);
		clean_up(RET_FAIL);
	}
	int ret = description_parse_file(arch_fp, NULL, arch);
	//arch_print_description(&description, 0);
	fclose(arch_fp);
	if (ret == RET_FAIL)
	{
		clean_up(RET_FAIL);
	}
}

void sana_fe::set_net(char* filename){
	FILE* network_fp = fopen(filename, "r");
	if (network_fp == NULL)
	{
		INFO("Network data (%s) failed to open.\n", filename);
		clean_up(RET_FAIL);
	}
	INFO("Reading network from file.\n");
	int ret = description_parse_file(network_fp, &net, arch);
	fclose(network_fp);
	if (ret == RET_FAIL)
	{
		clean_up(RET_FAIL);
	}
	network_check_mapped(&net);

	arch_create_axons(arch);

	// Change Potential logging with new headers from net.
	if (sim->log_potential){
		set_pot_flag(true);
	}
}

double sana_fe::get_power()
{
	if (sim->total_sim_time > 0.0)
	{
		return sim->total_energy / sim->total_sim_time;
	}
	else
	{
		return 0.0;
	}
}
vector<int> sana_fe::get_status(int gid){
	vector<int> statuses = vector<int>();

	if (gid >= net.neuron_group_count)
	{
		INFO("Error: Got gid of %d with only %d groups in net.\n",
			gid, net.neuron_group_count);
		return statuses;
	}
	for (int i = 0; i < net.groups[gid].neuron_count; ++i)
	{
		statuses.push_back(net.groups[gid].neurons[i].neuron_status);
	}
	return statuses;
}

void sana_fe::sim_summary()
{
	sim_write_summary(stdout, sim);

	sim->stats_fp = fopen("run_summary.yaml", "w");
	if (sim->stats_fp != NULL)
	{
		sim_write_summary(sim->stats_fp, sim);
	}
}
vector<vector<int>> SANA_FE::run_summary()
{
	print_run_data(stdout, &run_data);

	// Could write intermediate run data here
	// sim->stats_fp = fopen("run_summary.yaml", "w");
	// if (sim->stats_fp != NULL)
	// {
	// 	print_run_data(sim->stats_fp, &run_data);
	// }

	// Return 2D vector of spiking tiles, auto clears
	// vector after return.
	Vector_Cleanup_Class help_class(arch);
	return arch->spike_vector;
}

void sana_fe::clean_up(int ret)
{
	// Free any larger structures here
	network_free(&net);
	arch_free(arch);

	// Close any open files here
	if (sim->potential_trace_fp != NULL)
	{
		fclose(sim->potential_trace_fp);
	}
	if (sim->spike_trace_fp != NULL)
	{
		fclose(sim->spike_trace_fp);
	}
	if (sim->message_trace_fp != NULL)
	{
		fclose(sim->message_trace_fp);
	}
	if (sim->perf_fp != NULL)
	{
		fclose(sim->perf_fp);
	}
	if (sim->stats_fp != NULL)
	{
		fclose(sim->stats_fp);
	}

	// Free the simulation structure only after we close all files
	free(sim);

	if (ret == RET_FAIL)
	{
		exit(1);
	}
	else
	{
		exit(0);
	}
}

void run(struct simulation *sim, struct network *net, struct architecture *arch)
{
	// TODO: remove the need to pass the network struct, only the arch
	//  should be needed (since it links back to the net anyway)
	// Run neuromorphic hardware simulation for one timestep
	//  Measure the CPU time it takes and accumulate the stats
	struct timespec ts_start, ts_end, ts_elapsed;
	struct timestep *ts = &(sim->ts);

	// Measure the wall-clock time taken to run the simulation
	//  on the host machine
	clock_gettime(CLOCK_MONOTONIC, &ts_start);
	sim_timestep(ts, net, arch);
	// Calculate elapsed time
	clock_gettime(CLOCK_MONOTONIC, &ts_end);
	ts_elapsed = calculate_elapsed_time(ts_start, ts_end);

	sim->total_energy += ts->energy;
	sim->total_sim_time += ts->sim_time;
	sim->total_spikes += ts->spike_count;
	sim->total_neurons_fired += ts->total_neurons_fired;
	sim->total_messages_sent += ts->packets_sent;
	if (sim->log_spikes)
	{
		sim_trace_record_spikes(sim, net);
	}
	if (sim->log_potential)
	{
		sim_trace_record_potentials(sim, net);
	}
	if (sim->log_perf)
	{
		sim_perf_log_timestep(ts, sim->perf_fp);
	}
	if (sim->log_messages)
	{
		for (int i = 0; i < ARCH_MAX_CORES; i++)
		{
			for (int j = 0; j < ts->message_queues[i].count; j++)
			{
				Message *m = &(ts->messages[i][j]);
				if (m->dest_neuron != NULL)
				{
					// Ignore dummy messages (without a
					//  destination). These are inserted to
					//  account for processing that doesn't
					//  result in a spike being sent
					sim_trace_record_message(sim, m);
				}
			}
		}
	}
	sim->timesteps = ts->timestep;
	sim->wall_time += (double) ts_elapsed.tv_sec+(ts_elapsed.tv_nsec/1.0e9);
	TRACE1("Time-step took: %fs.\n",
		(double) ts_elapsed.tv_sec+(ts_elapsed.tv_nsec/1.0e9));

}

struct timespec calculate_elapsed_time(
	struct timespec ts_start, struct timespec ts_end)
{
	// Calculate elapsed wall-clock time between ts_start and ts_end
	struct timespec ts_elapsed;

	ts_elapsed.tv_nsec = ts_end.tv_nsec - ts_start.tv_nsec;
	ts_elapsed.tv_sec = ts_end.tv_sec - ts_start.tv_sec;
	if (ts_end.tv_nsec < ts_start.tv_nsec)
	{
		ts_elapsed.tv_sec--;
		ts_elapsed.tv_nsec += 1000000000UL;
	}

	return ts_elapsed;
}

void store_data_init(run_ts_data* data, simulation* sim, int timesteps)
{
	data->energy = sim->total_energy;
	data->time = sim->total_sim_time;
	data->spikes = sim->total_spikes;
	data->packets = sim->total_messages_sent;
	data->neurons = sim->total_neurons_fired;
	data->wall_time = sim->wall_time;
	data->timestep_start = sim->timesteps;
	data->timesteps = timesteps;
}

void store_data(run_ts_data* data, simulation* sim)
{
	data->energy = sim->total_energy - data->energy;
	data->time = sim->total_sim_time - data->time;
	data->spikes = sim->total_spikes - data->spikes;
	data->packets = sim->total_messages_sent - data->packets;
	data->neurons = sim->total_neurons_fired - data->neurons;
	data->wall_time = sim->wall_time - data->wall_time;
}

void print_run_data(FILE *fp, run_ts_data* data)
{
	fprintf(fp, "energy: %e\n", data->energy);
	fprintf(fp, "time: %e\n", data->time);
	fprintf(fp, "total_spikes: %ld\n", data->spikes);
	fprintf(fp, "total_packets: %ld\n", data->packets);
	fprintf(fp, "total_neurons_fired: %ld\n", data->neurons);
	fprintf(fp, "wall_time: %lf\n", data->wall_time);
	fprintf(fp, "executed from: %ld to %ld timesteps\n", data->timestep_start,
	data->timestep_start+data->timesteps);
}

PYBIND11_MODULE(sanafe, m) {
    m.doc() = R"pbdoc(
        SANA-FE CPP Module with Pybind11
        --------------------------------

        .. currentmodule:: simcpp

        .. autosummary::
           :toctree: _generate

		   SANA_FE
    )pbdoc";
`
	py::class_<sana_fe>(m, "sana_fe")
		.def(py::init())
		.def("init", &sana_fe::init)
        .def("update_neuron", &sana_fe::update_neuron)
        .def("run_timesteps", &sana_fe::run_timesteps, py::arg("timesteps") = 1)
		.def("set_input", &sana_fe::set_input)
		.def("open_perf_trace", &sana_fe::set_perf_flag, py::arg("flag") = true)
		.def("open_spike_trace", &sana_fe::set_spike_flag, py::arg("flag") = true)
		.def("open_potential_trace", &sana_fe::set_pot_flag, py::arg("flag") = true)
		.def("open_message_trace", &sana_fe::set_mess_flag, py::arg("flag") = true)
		.def("set_gui_flag", &sana_fe::set_gui_flag, py::arg("flag") = true)
		.def("set_arch", &sana_fe::set_arch)
		.def("set_net", &sana_fe::set_net)
		.def("get_power", &sana_fe::get_power)
		.def("get_status", &sana_fe::get_status)
		.def("sim_summary", &sana_fe::sim_summary)
		.def("run_summary", &sana_fe::run_summary)
		.def("clean_up", &sana_fe::clean_up, py::arg("ret") = 0);
}
